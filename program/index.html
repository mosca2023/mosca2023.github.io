<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="content-type"
        content="text/html; charset=utf8" />
  <meta name="robots"
        content="all" />
  <meta name="generator"
        content="RapidWeaver" />
  <meta name="generatorversion"
        content="3.5.1 (Build 260)" />
  <!-- <link rel="icon"
        href="http://www.bici.eu/favicon.ico"
        type="image/x-icon" />
  <link rel="shortcut icon"
        href="http://www.bici.eu/favicon.ico"
        type="image/x-icon" /> -->

  <title>Program</title>
  <link rel="stylesheet"
        type="text/css"
        href=
        "../files/styles.css" />
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
</head>

<body>
  <div id="bodyIndent"></div>

  <div id="container">
    <!-- Start container -->

    <div id="pageHeader">
  <!-- Start page header -->

      <h1>Maison de la Chimie</h1>

      <h2>MOSCA'23: Meeting on String Constraints and Applications</h2>
      <!--#include virtual="page_header.html" -->

    </div><!-- End page header -->


    <!-- <div id="banner">
      <div id="logo">
        <img src="../files/bici-logo-web.jpg"
             alt="Site logo" />
      </div>

      <div id="insert"></div>
    </div> -->

    <div id="contentContainer">
      <!-- Start main content wrapper -->

      <div id="content">
        <!-- Start content -->

        <!-- BEGIN_EDIT_THIS -->

<h2>Preliminary Programme of the Workshop</h2>

<!-- <pre>
9:00- 10:00, Vijay Ganesh, University of Waterloo
10:00-10:30 Amit Goel, Amazon Web Service
10:30-11:00 Coffee break 
11:00-11:30 Roberto Amadini, University of Bologna
11:30-12:00 Lukas Holik, Brno University of Technology 


2:00-3:00 Cesare Tinelli, the University of Iowa
3:00-3:30 Anthony Widjaja Lin, Technical University of Kaiserslautern
3:30-4:00 Coffee break
4:00-5:00 Panel Discussion
</pre> -->

<p>
  <b>Monday, July 17</b>
  <table border=0 style="width:95%">
  <tr style="background-color:#ffcc66" align=center>
    <td style="width:80px;">Session 1</td>
    <td></td>
  </tr>
  <tr style="background-color:#dff0d8">
    <td style="width:70px;">9:00-10:00</td>
    <td>
    Vijay Ganesh, University of Waterloo<br>
  <i>Title: TBD</i><br>
    </td>
  </tr>
  <tr style="background-color:#dff0d8">
    <td style="width:70px;">10:00-10:30</td>
    <td>
    Amit Goel, Amazon Web Service<br>
    <i>Title: TBD</i>
    </td>
      </tr>
  
  <tr align=center>
    <td>10:30-11:00</td>
    <td>Coffee break</td>
  </tr>
  
  <tr style="background-color:#ffcc66" align=center>
    <td style="width:70px;">Session 2</td>
    <td></td>
  </tr>
  <tr style="background-color:#dff0d8">
    <td>11:00-11:30</td>
    <td>
      Roberto Amadini, University of Bologna<br>
  <i>Title: TBD
  </i>
    </td>
    </tr>
  <tr style="background-color:#dff0d8">
    <td>11:30-12:00</td>
    <td>
      Lukas Holik, Brno University of Technology<br>
        <i>Title: TBD</i> 
        <br>
    </td>
    </tr>
    
  <tr align=center>
    <td></td>
    <td>Lunch break</td>
  </tr>
  
  <tr style="background-color:#ffcc66" align=center>
    <td style="width:70px;">Session 3</td>
    <td></td>
  </tr>
  
  <tr style="background-color:#dff0d8">
    <td>14:00-15:00</td>
    <td>
      Cesare Tinelli, the University of Iowa<br>
    <i>Title: TBD</i>
    </td>
  </tr>
  <tr style="background-color:#dff0d8">
    <td>15:00-15:30</td>
    <td>
      Anthony Widjaja Lin, Technical University of Kaiserslautern<br>
    <i>Title: TBD</i>
    </td>
  </tr>
  
  <tr align=center>
    <td>15:30-16:00</td>
    <td>Coffee break</td>
  </tr>
  
  <tr style="background-color:#ffcc66" align=center>
    <td style="width:70px;">Session 4</td>
    <td></td>
  </tr>
  
  <tr style="background-color:#dff0d8">
    <td>16:00-17:00</td>
    <td>
      Panel Discussion
    </td>
  </tr>
  </table>
  </p>

<!-- <p>
<b>Monday, May 6</b>
<table border=0 style="width:95%">
<tr style="background-color:#ffcc66" align=center>
  <td style="width:70px;">Session 1</td>
  <td></td>
</tr>
<tr style="background-color:#dff0d8">
  <td style="width:70px;">08:45-09:00</td>
  <td>
  Anthony Lin/Philipp Rümmer<br>
<i>Opening</i><br>
  </td>
</tr>
<tr style="background-color:#dff0d8">
  <td style="width:70px;">9:00-10:00</td>
  <td>
  Volker Diekert<br>
  <i>A Word Equation Tutorial</i> (<a href="../slides/diekert.pdf">Slides</a>)
  </td>
    </tr>

<tr align=center>
  <td>10:00-10:30</td>
  <td>Coffee break</td>
</tr>

<tr style="background-color:#ffcc66" align=center>
  <td style="width:70px;">Session 2</td>
  <td></td>
</tr>
<tr style="background-color:#dff0d8">
  <td>10:30-11:30</td>
  <td>
  Andrew Reynolds / Cesare Tinelli<br>
<i>SMT and CVC4 for Strings</i> (<a href="../slides/tinelli.pdf">Slides</a>)
  <button type="button" id="andrew">Show abstract</button>
  <br>
  <div id="andrew_abstract" style='display: none;'>
      Abstract:
In the past several years, Satisfiability Modulo Theories (SMT) solvers have
been extended for reasoning about quantifier-free constraints in the theory of
unbounded strings and regular expressions. Although decidability of this theory
is unknown, many of these solvers are highly efficient for constraints that
commonly occur in practice. This talk overviews the main algorithms used by
the SMT solver CVC4 for handling string constraints. We focus on its core theory
solver for strings, regular expressions and length constraints. We then
cover its more advanced features, including its finite model finding strategy
for strings of bounded length, context-dependent simplification for extended
string functions and its support for regular expression elimination.
  </div>
  </td>
  </tr>
<tr style="background-color:#dff0d8">
  <td>11:30-12:00</td>
  <td>
  Nikolaj Bjørner<br>
      <i>Strings in Z3</i> (<a href="../slides/nbjorner.pptx">Slides</a>)
      <br>
  </td>
  </tr>
<tr style="background-color:#dff0d8">
  <td>12:00-12:30</td>
  <td>
  Rupak Majumdar<br>
<i>On Quadratic Word Equations</i><br>
  </td>
  </tr>
  
<tr align=center>
  <td>12:30-14:00</td>
  <td>Lunch break</td>
</tr>

<tr style="background-color:#ffcc66" align=center>
  <td style="width:70px;">Session 3</td>
  <td></td>
</tr>

<tr style="background-color:#dff0d8">
  <td>14:00-15:00</td>
  <td>
  Corina Pasareanu<br>
  <i>Symbolic Execution with Strings</i>
  <button type="button" id="corina">Show abstract</button>
  <br>
  <div id="corina_abstract" style='display: none;'>
      Abstract:
I plan to discuss the role of constraint solving and model counting for string constraints in the context of symbolic execution, with an application to side channel analysis.
  </div>
  </td>
</tr>

<tr align=center>
  <td>15:00-15:30</td>
  <td>Coffee break</td>
</tr>

<tr style="background-color:#ffcc66" align=center>
  <td style="width:70px;">Session 4</td>
  <td></td>
</tr>

<tr style="background-color:#dff0d8">
  <td>15:30-16:00</td>
  <td>
  Johannes Kinder<br>
  <i>Complex Regular Expressions</i> (<a href="../slides/kinder.pdf">Slides</a>)<br>
  </td>
</tr>
<tr style="background-color:#dff0d8">
  <td>16:00-16:30</td>
  <td>
  Musard Balliu<br>
   <del><i>String Problems in Security Analysis</i></del><br>
  </td>
  </tr>
<tr style="background-color:#dff0d8">
  <td>16:30-17:00</td>
  <td>
  Liana Hadarean<br>
   <i>String Solving at Amazon</i><br>
  </td>
  </tr>
</table>
</p>


<p>
<b>Tuesday, May 7</b>
<table border=0 style="width:95%">
<tr style="background-color:#ffcc66" align=center>
  <td style="width:70px;">Session 5</td>
  <td></td>
</tr>
<tr style="background-color:#dff0d8">
  <td style="width:70px;">9:00-10:00</td>
  <td>
  Artur Jez<br>
  <i>On Recompression for Word Equations</i> (<a href="../slides/jez.pdf">Slides</a>)
  <button type="button" id="artur">Show abstract</button>
  <br>
  <div id="artur_abstract" style='display: none;'>
  Abstract:
  A word equation is given by two strings over disjoint alphabets of letters and variables and we ask whether there is a substitution that makes the sides of the equation truly equal as strings. Recently, a new PSPACE solution to this problem was proposed, it is based on the recompression technique, which compresses simple substrings of the equation (compression of pairs ab by a new symbol c, where a ≠ b, and compression of maximal substrings a^l by a new symbol a_l) and modifying the equation so that such operations are sound; those modifications boil down to substitutions X → aX and X → Xb.

The analysis focuses on the way the equation is stored and changed rather than on the combinatorics of words. This approach greatly simplified many existing proofs and algorithms. Moreover, it is also applicable to restricted cases (for instance: one-variable equations, but also compressed string testing) and to generalisations (regular constraints, involution, partial commutation, tree equations, etc.).
  </div>
  </td>
  </td>
</tr>

<tr align=center>
  <td>10:00-10:30</td>
  <td>Coffee break</td>
</tr>

<tr style="background-color:#ffcc66" align=center>
  <td style="width:70px;">Session 6</td>
  <td></td>
</tr>
<tr style="background-color:#dff0d8">
  <td>10:30-11:00</td>
  <td>
  Dirk Nowotka / Florin Manea / Joel Day<br>
<i>On Fragments of Word Equations</i>
       (<a href="../slides/day.pdf">Slides</a>)<br>
  </td>
  </tr>
<tr style="background-color:#dff0d8">
  <td>11:00-11:30</td>
  <td>
  Margus Veanes<br>
<i>Symbolic Transducers</i><br>
  </td>
  </tr>
<tr style="background-color:#dff0d8">
  <td>11:30-12:00</td>
  <td>
  Matthew Hague / Zhilin Wu<br>
      <i>Generic and Complete Algorithms for Straight-Line String Constraints</i>
       (<a href="../slides/hague.pdf">Slides</a>)
  <button type="button" id="matt">Show abstract</button>
  <br>
  <div id="matt_abstract" style='display: none;'>
      Abstract: Path-feasibility is an important problem in the symbolic 
      execution of 
string-manipulating programs. A symbolic path is given as a finite, 
loop-free sequence of assertions and assignments and the task is to find 
concrete instantiations of the symbolic variables that satisfy all 
assertions along the path. If such instantiations are found, then the 
path is feasible. Such a path may witness an error in the program being 
analysed.

Recent research has identified a number of string operations that can be 
supported by path-feasibility algorithms. We contribute two semantic 
conditions, which, if satisfied by the assertions and assignments in the 
program, imply decidability of the path-feasibility problem. This 
decidability is shown via a generic feasibility-checking algorithm.

We have implemented this algorithm in a tool OSTRICH, which checks 
satisfiability of straight-line string constraints (paths). We have 
compared this tool with other leading solvers over a wide range of 
popular benchmarks. OSTRICH is competitive on well-supported benchmarks, 
while also increasing the expressivity and extensibility of the 
string-constraints supported.
  </div>
  </td>
  </tr>
<tr style="background-color:#dff0d8">
  <td>12:00-12:30</td>
  <td>
  Mohammed Faouzi Atig / Yu-Fang Chen<br>
<i>Solving String Constraints through Flatten and Conquer</i><br>
  </td>
  </tr>
  
<tr align=center>
  <td>12:30-14:00</td>
  <td>Lunch break</td>
</tr>

<tr style="background-color:#ffcc66" align=center>
  <td style="width:70px;">Session 7</td>
  <td></td>
</tr>

<tr style="background-color:#dff0d8">
  <td>14:00-15:00</td>
  <td>
  Pablo Barcelo<br>
  <i>Graph Databases vs. String Solving</i> (<a href="../slides/barcelo.pdf">Slides</a>)<br>
  </td>
</tr>

<tr align=center>
  <td>15:00-15:30</td>
  <td>Coffee break</td>
</tr>

<tr style="background-color:#ffcc66" align=center>
  <td style="width:70px;">Session 8</td>
  <td></td>
</tr>

<tr style="background-color:#dff0d8">
  <td>15:30-16:00</td>
  <td>
  Diego Figueira<br>
  <i>Synchronized word relations</i>
  <button type="button" id="diego">Show abstract</button>
  <br>
  <div id="diego_abstract" style='display: none;'>
      Abstract: 
In this talk I will give an overview on a way of defining classes of word relations called Synchronized relations. This framework yields an infinite number of classes living within the well-studied class of Rational relations, among which we can find the classes Automatic, Recognizable, or length-preserving relations.

A natural approach to defining binary word relations over a finite alphabet A is through two-tape finite state automata, which can be seen as regular languages L over the alphabet {1,2} x A, where (i,a) is interpreted as reading letter a from tape i. Thus, a word w of the language L denotes the pair (u_1,u_2) in A* x A* in which u_i is the projection of w onto i-labelled letters. While this formalism defines the well-studied class of Rational relations due to Nivat’s Theorem (a.k.a. non-deterministic finite state transducers), enforcing restrictions on the reading regime from the tapes, that we call synchronization, yields various sub-classes of relations. Such synchronization restrictions are imposed through regular properties on the projection of the language onto {1,2}. In this way, for each regular language C contained in {1,2}*, one obtains a class Rel(C) of relations. I will show some recent results on this collection of classes of relations, based on joint work with María Emilia Descotte, Santiago Figueira, Leonid Libkin, and Gabriele Puppis.
  </div>
  </td>
</tr>
<tr style="background-color:#dff0d8">
  <td>16:00-16:30</td>
  <td>
  Krishna S.<br>
   <i> Building Blocks for Regular Functions </i>
  <button type="button" id="krishna">Show abstract</button>
  <br>
  <div id="krishna_abstract" style='display: none;'>
   Abstract:
   Functional MSO transductions, deterministic two-way transducers, as well as
streaming string transducers are all equivalent models for regular functions. In this talk, we discuss how regular functions, either on finite or infinite words can be described using regular transducer expressions (RTE). The basic building blocks  of these expressions are simple and natural functions. I will touch upon two such building blocks : one which uses the composition operation, and one which does not.  
  </div>
  </td>
  </tr>
<tr style="background-color:#dff0d8">
  <td>16:30-16:45</td>
  <td>
  Dmitry Chistikov<br>
   <i>Re-pairing brackets</i>
  <button type="button" id="dima">Show abstract</button>
  <br>
  <div id="dima_abstract" style='display: none;'>
   Abstract:
   Consider the following one-player game. Take a well-formed sequence of
opening and closing brackets (a word in the Dyck language). As a move, the
player can pair any opening bracket with any closing bracket to its right,
erasing them. The goal is to re-pair (erase) the entire sequence, and the
cost of a strategy is measured by its width: the maximum number of
nonempty segments of symbols (separated by blank space) seen during the
play.

In the talk, I will discuss this re-pairing game and upper and lower
bounds on the minimum width sufficient for re-pairing. I will also talk
about connections between this game on strings and automata theory.
  </td>
  </tr>
<tr style="background-color:#dff0d8">
  <td>16:45-17:00</td>
  <td>
  Reino Niskanen<br>
   <i>Monadic Decomposability of Regular Relations</i><br>
  </td>
  </tr>
<tr style="background-color:#dff0d8">
  <td>17:00-17:15</td>
  <td>
 Ruzica Piskac <br>
  <i>
    Do real world users need string synthesis?
  </i>
       (<a href="../slides/piskac.pdf">Slides</a>)
  <button type="button" id="ruzica">Show abstract</button>
  <br>
  <div id="ruzica_abstract" style='display: none;'>
    Abstract: Writing a scripts can be a tedious and error-prone task, especially
for end users.  When requesting help, users will often continually
provide more examples until their intentions are understood.
Recognizing this, we developed an interactive programming by example
framework, called StriSynth, that allows end-users to automatically
generate stand-alone scripts by incrementally providing examples, and
receive feedback throughout the process. To investigate the impact of
StriSynth and programming by example paradigm on real-world users, we
built a study around StriSynth, and recruited 27 working IT
professionals to participate.  In our study we asked the users to
complete three tasks with StriSynth, and the same three tasks with
PowerShell, a traditional scripting language.  We found that, although
our participants completed the tasks more quickly with StriSynth, they
reported that they believed PowerShell to be a more helpful tool.
  </div>
  </td>
  </tr>

</table>
</p>


<p>
<b>Wednesday, May 8</b>

<table border=0 style="width:95%">
<tr style="background-color:#ffcc66" align=center>
  <td style="width:70px;">Session 9</td>
  <td></td>
</tr>
<tr style="background-color:#dff0d8">
  <td style="width:70px;">9:00-9:30</td>
  <td>
  Nestan Tsiskaridze<br>
  <i>Exploring what is decidable in strings with CVC4</i>
  <button type="button" id="nestan">Show abstract</button>
  <br>
  <div id="nestan_abstract" style='display: none;'>
Abstract: Identifying decidable fragments in the theory of strings has been a quest for researchers in both theoretical and practical avenues. The latter has become more of significant interest with the recent attempts in automating reasoning community to give the best effort towards the automation of reasoning over undecidable theories. A major difficulty in reasoning over strings is that, in general, the satisfiability problem of any reasonably comprehensive theory of character strings is undecidable. However, one can indicate several restricted, but still quite useful, fragments of the theory of strings that are decidable. Recent research on the string theory has focused on identifying decidable fragments suitable for automated analysis and developing efficient solvers for them. This talk presents our attempts towards the search for decidable fragments in the theory of string with the string calculus defined in CVC4. We will explore the approaches we tried to this extent and share where these efforts led us.
  </div> 
  </td>
  </td>
</tr>
<tr style="background-color:#dff0d8">
  <td style="width:70px;">9:30-10:00</td>
  <td>
  Zhilin Wu<br>
  <i>Extending OSTRICH to integer data type</i>
  <button type="button" id="zhilin">Show abstract</button>
  <br>
  <div id="zhilin_abstract" style='display: none;'>
  Abstract:
  OSTRICH is an expressive, easy, efficient, and extensible string solver 
recently developed for path feasibility problem of string-manipulating 
programs with complex string operations. The crux of OSTRICH is a simple 
decision procedure which propagates the regular language constraints in 
a backward manner via the regularity-preserving pre-image computation. 
Nevertheless, although OSTRICH is expressive in the sense of string 
operations involving only the string data type, it still does not 
support the  operations involving both the string and integer data type, 
e.g. string length, substring, and indexof functions. In this talk, I 
will report our ongoing work to extend OSTRICH to integer data type. 
This extension is built on integer cost register automata (ICRA), a 
nondeterministic variant of cost register automata introduced by Alur 
et. al. (LICS 2013), where the cost domain is interpreted as the set of 
integers. Then the decision procedure of OSTRICH can be seamlessly 
extended by replacing finite-state automata with ICRA. With this 
extension, OSTRICH is then capable of solving string constraints 
involving both the string and integer data types, i.e.  string 
constraints that contain string length, indexof, and substring 
functions, in addition to those operations already supported by the 
current version of OSTRICH.
  </div>
  </td>
  </td>
</tr>
<tr style="background-color:#dff0d8">
  <td style="width:70px;">10:00-10:30</td>
  <td>
  Murphy Berzish<br>
  <i>Length-Aware Regular Expression Solving in Z3str3</i>
       (<a href="../slides/berzish.pdf">Slides</a>)
  </td>
  </td>
</tr>

<tr align=center>
  <td>10:30-11:00</td>
  <td>Coffee break</td>
</tr>

<tr style="background-color:#ffcc66" align=center>
  <td style="width:70px;">Session 10</td>
  <td></td>
</tr>

<tr style="background-color:#dff0d8">
  <td>11:00 - 12:30 (tbc)</td>
  <td>
  Cesare Tinelli<br>
  <i>Working Session on SMT-LIB for Strings</i><br>
  </td>
</tr>

<tr align=center>
  <td>12:30-14:00</td>
  <td>Lunch break</td>
</tr>

<tr style="background-color:#ffcc66" align=center>
  <td>Afternoon</td>
  <td>Excursion to <strong>Ravenna</strong> (bus leaves at 14:00, and is back in Bertinoro late evening) </td>
</tr>

</table>
</p>


<p>
<b>Thursday, May 9</b>
<table border=0 style="width:95%">
<tr style="background-color:#ffcc66" align=center>
  <td style="width:70px;">Session 11</td>
  <td></td>
</tr>
<tr style="background-color:#dff0d8">
  <td style="width:70px;">9:00-09:50</td>
  <td>
  Tomas Vojnar<br>
  <i>A Regular Model Checking Tutorial</i> (<a href="../slides/vojnar.pdf">Slides</a>)
  </td>
  </td>
</tr>
<tr style="background-color:#dff0d8">
  <td style="width:70px;">09:50-10:10</td>
  <td>
  Ondra Lengal<br>
      <i>Fair Termination for Parameterized Probabilistic Concurrent Systems</i>
       (<a href="../slides/lengal-1.pdf">Slides</a>)
  </td>
  </td>
</tr>
<tr style="background-color:#dff0d8">
  <td style="width:70px;">10:10-10:30</td>
  <td>
  Chih-Duo Hong<br>
  <i>Regular Model Checking beyond Safety</i>
  </td>
  </td>
</tr>

<tr align=center>
  <td>10:30-11:00</td>
  <td>Coffee break</td>
</tr>

<tr style="background-color:#ffcc66" align=center>
  <td style="width:70px;">Session 12</td>
  <td></td>
</tr>
<tr style="background-color:#dff0d8">
  <td>11:00-11:30</td>
  <td>
  Richard Mayr<br>
      <i>Simulation and Anti-chains for Automata</i>
      (<a href="../slides/mayr.pdf">Slides</a>)
  <button type="button" id="richard">Show abstract</button>
  <br>
  <div id="richard_abstract" style='display: none;'>
Abstract:
This talk gives an overview on techniques for solving computationally hard
problems for nondeterministic automata: language inclusion/equivalence
checking and automata minimization.
We focus on nondeterministic Buchi automata and NFAs, but the techniques
carry over to tree-automata.
Some techniques use logical subsumption to narrow the search space for a
counterexample: antichain methods and congruence base methods.
Other techniques use generalized types of simulation preorders
(multi-pebble and lookahead simulations) to manipulate automata,
e.g., merging state, removing states/transitions or witnessing
language inclusion outright.
Finally, we'll discuss some open questions and challenges.
A collection of current papers and tools is available at www.languageinclusion.org.
See also https://lmcs.episciences.org/5189
  </div>
  </td>
  </tr>
<tr style="background-color:#dff0d8">
  <td>11:30-12:00</td>
  <td>
  Ondrej Lengal<br>
<i>On WS1S</i>       (<a href="../slides/lengal-2.pdf">Slides</a>)
<br>
  </td>
  </tr>
<tr style="background-color:#dff0d8">
  <td>12:00-12:30</td>
  <td>
  Justin Pearson<br>
<i>On CP for Strings </i> (<a href="../slides/pearson.pdf">Slides</a>)<br>
  </td>
  </tr>
  
<tr align=center>
  <td>12:30-14:00</td>
  <td>Lunch break</td>
</tr>

<tr style="background-color:#ffcc66" align=center>
  <td style="width:70px;">Session 13</td>
  <td></td>
</tr>

<tr style="background-color:#dff0d8">
  <td>14:00-14:30</td>
  <td>
  Arlen Cox<br>
  <i>Model Checking Regular Language Constraints</i> (<a href="../slides/cox.pdf">Slides</a>)<br>
  </td>
</tr>
<tr style="background-color:#dff0d8">
  <td>14:30-15:00</td>
  <td>
  Fang Yu / Roland Jiang<br>
  <i>Solving String Constraints through Hardware/Software Model Checking</i>
  (<a href="../slides/jhjiang.pdf">Slides</a>)
  <button type="button" id="jiang">Show abstract</button>
  <br>
  <div id="jiang_abstract" style='display: none;'>
  Abstract:
  Strings with length constraints are prominent in software security analysis. In this talk, we will present logic circuit representation for (nondeterministic) finite automata to support various string and automata manipulation operations. It enables both counterexample generation and filter synthesis in string constraint solving. By using the new data structure, automata with large state spaces and/or alphabet sizes can be efficiently represented. The representation is further augmented with length encoding. By converting string and length constraints into a dependency graph of manipulations over length-encoded automata, a symbolic model checker for infinite state systems can be leveraged as an engine for the analysis of string and length constraints. Experiments show that the method has its unique capability of handling complex string and length constraints not solvable by other methods. 
  </div>
  </td>
</tr>
<tr style="background-color:#dff0d8">
  <td>15:00-15:15</td>
  <td>
  Mitja Kulczynski<br>
  <i>On Solving Word Equations Using SAT</i>
  <button type="button" id="mitja">Show abstract</button>
  <br>
  <div id="mitja_abstract" style='display: none;'>
  Abstract:
  We present Woorpje, a string solver for bounded word equations
(i.e., equations where the length of each variable is upper bounded by a
given integer). Our algorithm works by reformulating the satisfiability
of bounded word equations as a reachability problem for nondeterministic
finite automata, and then carefully encoding this as a propositional
logic satisfiability problem, which we then solve using the well-known
Glucose SAT-solver. This approach has the advantage of allowing for the
natural inclusion of additional linear length constraints.
  </div>
  </td>
</tr>
<tr style="background-color:#dff0d8">
  <td>15:15-15:30</td>
  <td>
  Petr Janku<br>
  <i>Sloth - Solver for String Constraints</i><br>
  </td>
</tr>
<tr style="background-color:#dff0d8">
  <td>15:30-15:45</td>
  <td>
  Fang Yu<br>
      <i>Model Counting over Strings Constraints</i>
       (<a href="../slides/fang.pdf">Slides</a>)<br>
  </td>
</tr>

<tr align=center>
  <td>15:45-16:15</td>
  <td>Coffee break</td>
</tr>

<tr style="background-color:#ffcc66" align=center>
  <td style="width:70px;">Session 14</td>
  <td></td>
</tr>

<tr style="background-color:#dff0d8">
  <td>16:15-17:00</td>
  <td>
   <i>Short talks</i><br>
  </td>
  </tr>
</table>
</p> -->

	<!-- END_EDIT_THIS -->

        <div class="clearer"></div>

        <div id="breadcrumbcontainer">
          <!-- Start the breadcrumb wrapper -->

          <ul>
            <li><a href=
            "../index.html">Home</a>&nbsp;&gt;&nbsp;</li>

            <li><a href=
            "index.html">Program</a>&nbsp;&gt;&nbsp;</li>
          </ul>
        </div><!-- End breadcrumb -->
      </div><!-- End content -->
    </div><!-- End main content wrapper -->

    <div id="sidebarContainer">
      <!-- Start Sidebar wrapper -->

      <div id="navcontainer">
        <!-- Start Navigation -->

        <ul>
          <li><a href="../index.html"
             rel="self">Home</a></li>

          <li><a href="index.html"
             rel="self"
             id="current"
             name="current">Program</a></li>

          <li><a href="../dates/index.html"
             rel="self">Important Dates</a></li>

          <li><a href="../organization/index.html"
             rel="self">Organization</a></li>

<!--          <li><a href="../registration/index.html"
             rel="self">Registration</a></li>

          <li><a href="../sponsorship/index.html"
             rel="self">Sponsorship</a></li> -->

          <li><a href="../participants/index.html"
             rel="self">List of Participants</a></li>

          <li><a href="../location/index.html"
             rel="self">Location</a></li>

          <!-- <li><a href="../howto/index.html"
             rel="self">How to Reach Bertinoro</a></li>

          <li><a href="../weather/index.html"
             rel="self">Local Weather Forecast</a></li> -->
        </ul>
      </div><!-- End navigation -->

      <div class="sideHeader"></div><!-- Sidebar header -->

      <div id="sidebar">
        <!-- Start sidebar content -->

        <br />
        <!-- sidebar content you enter in the page inspector -->
         <!-- sidebar content such as the blog archive links -->
      </div><!-- End sidebar content -->
    </div><!-- End sidebar wrapper -->

    <div class="clearer"></div>
  </div><!-- End container -->

  <div id="footer">
    <!-- Start Footer -->

    <p>© 2023</p>
  </div><!-- End Footer -->

    <script>
  $(document).ready(function(){
    $("#ruzica").click(function(){
        $("#ruzica_abstract").toggle();
    });

    $("#corina").click(function(){
        $("#corina_abstract").toggle();
    });

    $("#andrew").click(function(){
        $("#andrew_abstract").toggle();
    });

    $("#richard").click(function(){
        $("#richard_abstract").toggle();
    });

    $("#jiang").click(function(){
        $("#jiang_abstract").toggle();
    });

    $("#zhilin").click(function(){
        $("#zhilin_abstract").toggle();
    });

    $("#mitja").click(function(){
        $("#mitja_abstract").toggle();
    });

    $("#nestan").click(function(){
        $("#nestan_abstract").toggle();
    });

    $("#artur").click(function(){
        $("#artur_abstract").toggle();
    });

    $("#dima").click(function(){
        $("#dima_abstract").toggle();
    });

    $("#diego").click(function(){
        $("#diego_abstract").toggle();
    });

    $("#krishna").click(function(){
        $("#krishna_abstract").toggle();
    });

    $("#matt").click(function(){
        $("#matt_abstract").toggle();
    });
  });


    </script>

</body>
</html>
